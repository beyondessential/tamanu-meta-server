# Agent Rules for tamanu-meta-server

Avoid writing large summaries of actions taken when done.

## Project Structure Overview
- **Database crate**: Models, migrations, and database logic
- **Public server**: Internet-exposed API endpoints for device registration and updates
- **Private server**: Admin web interface using Leptos (SSR + hydration)
- **Commons**: Shared utilities, authentication, error handling

## Database Connection
- Database models are in `crates/database/src/` with re-exports in `lib.rs`
- Use migrations in `migrations/` directory for schema changes
- Use PostgreSQL native functions where possible (e.g., `position()` for binary substring searches)
- Complex queries: Prefer database-level operations over in-memory filtering

## Code Style & Patterns
- Follow existing Rust conventions in the codebase
- Never add useless comments if what the code does is obvious enough, especially in CSS
- Use `AppError` variants for error handling, map to appropriate HTTP status codes in `IntoResponse`
- Update ERRORS.md when adding new error types, the heading must match the error problem type
- Use `commons_tests::db::TestDb::run()` for database-only tests
- Use `commons_tests::server::run()` for HTTP endpoint tests
- Use `commons_tests::server::run_with_device_auth()` for authenticated device tests in the public server
- Admin pages: Restrict frontend with `is_current_user_admin()` resource and use `admin_guard()` in server functions

## Leptos Private Server Architecture
- **Frontend/Backend Separation**: Code must build in both SSR and hydrate modes
- **SSR Pattern**: Put database/backend imports in `#[cfg(feature = "ssr")]` sections, following `fns/statuses.rs` structure
- **Server Functions**: Use `#[server]` functions that delegate to `ssr::` module functions
- **Data Structures**: Create separate serializable structs for frontend (no direct database types)
- **Admin Guard**: Use `crate::fns::commons::admin_guard()` for admin authentication
- **Page Structure**: Follow pattern in `app/statuses.rs` and `app/admins.rs`

Example Leptos server function pattern:
```rust
#[server]
pub async fn my_function() -> Result<MyData> {
    ssr::my_function().await
}

#[cfg(feature = "ssr")]
mod ssr {
    use database::MyModel; // SSR-only imports here

    pub async fn my_function() -> Result<MyData> {
        let db = crate::fns::commons::admin_guard().await?;
        // Implementation here
    }
}
```

## Testing Patterns
- Use `#[tokio::test(flavor = "multi_thread")]` for async tests
- Database tests: `commons_tests::db::TestDb::run(|mut conn, _url| async move { ... })`
- HTTP tests: `commons_tests::server::run(|conn, public, private| async move { ... })`
- Device auth tests: `commons_tests::server::run_with_device_auth("role", |conn, cert, device_id, public, private| async move { ... })`
- In public-server, for authenticated tests, add `mtls-certificate` header: `.add_header("mtls-certificate", &cert)`
- In public-server, use `.add_header("mtls-certificate", &cert)` on test requests, do not set it on `public` or `private` server directly (these should not be `mut` in tests)
- Test both success and error scenarios (especially 404 cases for non-existent resources)
- For database tests, use direct model functions instead of HTTP endpoints
- Always include `use database::ModelName;` imports in test files
- Do not include `_test` suffix or prefix in test filenames in `tests/` directory
- Calling Leptos Server Functions in private-server tests:
  - Server functions are exposed at `/api/private_server/fns/<module>/<function>` (e.g., `/api/private_server/fns/statuses/server_ids`)
  - Use `.form(&[("param_name", "param_value")])` for parameters (not `.json()`)
  - Use `.post()` without body for functions with no parameters

## Frontend Development
- Pages go in `crates/private-server/src/app/`
- Server functions go in `crates/private-server/src/fns/`
- Common components go in `crates/private-server/src/components/`
- CSS files go in `static/private/`
- Add routes in `crates/private-server/src/app.rs`
- Use Leptos signals for state management
- Handle async operations with `Resource` and `Action`

## Development Workflow
- Always check: `just check` for basic compilation
- Always check: `just build-frontend` for frontend compatibility
- Run full test suite: `just test`
- Run specific tests: `just test-name <test_name>`
- Verify no compilation warnings in tests and main code

## Troubleshooting and common mistakes
- Always use just for tests, never use `cargo test`.
- Unless you've done wide-ranging changes, prefer to test specific packages with `just test-package <package_name>` instead of the full test suite.
- If you're trying to import diesel in the private-server crate, stop that and put database stuff in the database crate instead.
- When files change from under you (ie when the dev changes things without telling you), assume those changes are intentional instead of reverting them.
- If you're not sure, STOP AND ASK.
